# 第七章 面向对象编程(中级)

* 包
* 访问权限修饰符
* **封装**
* **继承**
* **多态**
* Super
* overwrite
* Object类详解
* 断点调试

---
**idea快捷键：**
* 删除当前行：ctrl+d
* 复制当前行：ctrl+alt+向下箭头
* 补全代码：alt+/
* 添加注释和取消注释：ctrl+/
* 导入该行需要的类：alt+enter
* 格式化代码：ctrl+shift+L
* 快速运行程序：shift+f10
* 生成构造方法、set、get方法：alt+insert
* ctrl+h 查看类的层级关系
* ... ...

**idea模版:** 在file->settings->editor->Live templates查看有哪些模版，也可以自己增加模版
* sout：快速输出语句模版
* fori：for循环模版
* ... ...

---
## 7.1 包
&emsp; 包的本质就是创建不同文件夹来保存文件。**包的三大作用：**
1. 区分相同名字的类
2. 当类很多时，方便管理
3. 控制访问范围

### 7.1.1 包的命名
**命名规则**：只能包含数字、字母、下划线、小圆点；但不能数字开头、不能是关键字。<br>
**命名规范**：一般是小写字母加小圆点分隔，例如：com.xxx<br>

### 7.1.2 Java中常用的包
* java.lang.*：Java基本包，默认引入
* java.util.*：系统提供工具包
* java.net.*：网络包
* java.awt.*：UI包

---

## 7.2 访问修饰符
&emsp;Java提供四种访问修饰符，用于控制方法和属性的访问权限。
1. 公开级别：public修饰，都可以访问
2. 受保护级别：protected修饰，同一个包下的类以及子类可以访问
3. 默认级别：没有修饰符，同一个包下的类可以访问
4. 私有级别：private修饰，只有类本身可以访问<br>

**&emsp;使用注意事项：**
* 修饰符可以修饰属性、成员方法和类。但是只有默认和public才能修饰类
---

## 7.3 封装
**&emsp;面向对象编程的三大特征：封装、继承和多态** <br>
&emsp;**封装-encapsulation**就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只能通过被授权的操作才能对数据进行操作。<br><br>
&emsp;**封装的好处：**
* 隐藏实现细节
* 可以对数据进行验证，保证安全合理(比如定义猫类，猫的年龄不能超过100，就可以通过内部的封转进行控制)
<br>

**封装的实现步骤:**
1. 将属性进行私有化private
2. 提供一个公共的set方法，用于对属性的赋值
3. 提供一个公共的get方法，用于获取属性的值

---

## 7.4 继承
&emsp; **<font color=#aff999>为什么需要继承呢？</font>**<br>
&emsp; **看下面两段代码:**
```java
/**
 * 模拟小学生考试情况
 */
public class Pupil {
    public String name;
    public int age;
    private double score;

    public void setScore(double score) {
        this.score = score;
    }

    public void testing() {
        System.out.println("小学生" + name + "正在考小学数学...");
    }

    public void showInfo() {
        System.out.println("小学生" + name + "的小学数学成绩为：" + score);
    }
}
```
```java
/**
 * 模拟大学生考试情况
 */
public class Graduate {
    public String name;
    public int age;
    private double score;

    public void setScore(double score) {
        this.score = score;
    }

    public void testing() {
        System.out.println("大学生" + name + "正在考大学数学...");
    }

    public void showInfo() {
        System.out.println("大学生" + name + "的大学数学成绩为：" + score);
    }
}
```
&emsp;两个类的属性和方法有很多是相同，继承可以解决这种情况。<br>
&emsp;**继承介绍：** 继承可以解决代码服用问题，让编程更加靠近人类思维。当类存在多个相同的属性和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可。
<br>
&emsp;**继承的基本语法：** class 子类 extends 父类{}<br>
* 子类会自动拥有父类定义的属性和方法
* 父类又叫超类、基类
* 子类又叫派生类

### 7.4.1 继承的深入讨论|细节问题
1. 子类继承了父类所有的属性和方法，但是私有属性和方法不能在子类直接访问，要通过公共方法去访问。
2. 子类必须调用父类的构造器，完成父类的初始化。
3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器(定义了其他构造器但是没有无参构造器)，则必须在子类的构造器中用super去指定使用父类的哪个无参构造器去完成对父类的初始化工作，否则编译不会通过。
4. 如果希望指定去调用父类的某个构造器，需要使用super显式的去调用
5. super在使用时，需要放在构造器的第一行
6. <font color= #aff999>super()和this()都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器</font>
7. java所有的类都是Object类的子类
8. 父类构造器的调用不限于直接父类，将一直往上追溯到Object类
9. 子类最多只能基础一个父类(指直接继承)，即Java中是单根继承
10. 不能滥用继承，子类和父类之间必须满足is-a的逻辑关系

### 7.4.2 继承的本质分析
&emsp;通过案例分析，在创建子类对象时，内存中到底发生了什么？
```java
public class ExtendsTheory {
    public static void main(String[] args) {
        Son son = new Son();
        /*
        * 依次加载 Object--->GrandPa--->Father--->Son
        * 由上面的顺序分配类中的属性
        * */
        System.out.println(son.name);
        System.out.println(son.age);
        System.out.println(son.hobby);
        /*
        * 按照查找关系来返回信息
        * 1. 先查看子类是否有该属性，并且可以访问，即返回
        * 2. 子类无，则依次往上寻找*/
    }
}

class GrandPa {
    String name = "大头爷爷";
    String hobby = "旅游";
}

class Father extends GrandPa {
    String name = "大头爸爸";
    int age = 39;
}

class Son extends Father {
    String name = "大头儿子";
}
```

### 7.4.3 继承练习题
**第一题<br> 在下面代码中，main方法中执行<font color=#f0307f>B b = new B();</font>后，控制台会输出什么？** 
``` java
public class Practice01 {
    public static void main(String[] args) {
        B b = new B();
    }
}

class A {
    A() {
        System.out.println("a");
    }

    A(String name) {
        System.out.println("a name");
    }
}

class B extends A {
    B() {
        this("abc");
        System.out.println("b");
    }

    B(String name) {
        System.out.println("b name");
    }
}
```

**第二题<br> 在下面代码中，main方法中执行<font color=#f0307f>C02  = new C02();</font>后，控制台会输出什么？**
```java
public class Practice02 {
    public static void main(String[] args) {
        C02 c = new C02();
        /* 我是a类
         * 我是b的有参
         * 我是c的有参
         * 我是c的无参
         * */
    }
}

class A02 {
    A02() {
        System.out.println("我是A02类");
    }
}

class B02 extends A02 {
    B02() {
        System.out.println("我是B02的无参构造");
    }

    B02(String name) {
        System.out.println("我是B02的有参构造");
    }

}

class C02 extends B02 {
    C02() {
        this("Hello");
        System.out.println("我是C02的无参构造");
    }

    C02(String name) {
        super("hahaha");
        System.out.println("我是C02的有参构造");
    }
}
```

**第三题<br>**
* 编写Computer类，包含CPU、内存、硬盘等属性；getDetails方法用于返回Computer的详细信息。
* 编写PC子类，继承Computer类，添加特有属性[品牌brand]
* 编写NotePad子类，继承Computer类，添加特有属性[颜色color]
* 编写Test类，在main方法中创建PC和NotePad对象，分别给对象中的特有属性赋值，以及从Computer类继承的属性赋值，并使用方法打印输出信息。
```java

```